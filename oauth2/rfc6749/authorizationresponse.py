"""
    oauth2.rfc6749.authorizationresponse
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    About successful authorization responses for the “authorization grant” flow,
    from RFC6749 section 4.1.2:

        If the resource owner grants the access request, the authorization
        server issues an authorization code and delivers it to the client by
        adding the following parameters to the query component of the
        redirection URI using the "application/x-www-form-urlencoded" format,
        per Appendix B:

        code
            REQUIRED.  The authorization code generated by the
            authorization server.  The authorization code MUST expire
            shortly after it is issued to mitigate the risk of leaks.  A
            maximum authorization code lifetime of 10 minutes is
            RECOMMENDED.  The client MUST NOT use the authorization code
            more than once.  If an authorization code is used more than
            once, the authorization server MUST deny the request and SHOULD
            revoke (when possible) all tokens previously issued based on
            that authorization code.  The authorization code is bound to
            the client identifier and redirection URI.

        state
            REQUIRED if the "state" parameter was present in the client
            authorization request.  The exact value received from the
            client.


    About error responses, from RFC6749 section 4.1.2.1 and 4.2.2.1:

        If the request fails due to a missing, invalid, or mismatching
        redirection URI, or if the client identifier is missing or invalid,
        the authorization server SHOULD inform the resource owner of the
        error and MUST NOT automatically redirect the user-agent to the
        invalid redirection URI.

        If the resource owner denies the access request or if the request
        fails for reasons other than a missing or invalid redirection URI,
        the authorization server informs the client by adding the following
        parameters to the fragment component of the redirection URI using the
        "application/x-www-form-urlencoded" format, per Appendix B:

        error
            REQUIRED.  A single ASCII [USASCII] error code from the
            following:

            invalid_request [...]
            unauthorized_client [...]
            access_denied [...]
            unsupported_response_type [...]
            invalid_scope [...]
            server_error [...]
            temporarily_unavailable

            Values for the "error" parameter MUST NOT include characters
            outside the set %x20-21 / %x23-5B / %x5D-7E.

        error_description
            OPTIONAL.  Human-readable ASCII [USASCII] text providing
            additional information, used to assist the client developer in
            understanding the error that occurred.
            Values for the "error_description" parameter MUST NOT include
            characters outside the set %x20-21 / %x23-5B / %x5D-7E.

        error_uri
            OPTIONAL.  A URI identifying a human-readable web page with
            information about the error, used to provide the client
            developer with additional information about the error.
            Values for the "error_uri" parameter MUST conform to the
            URI-reference syntax and thus MUST NOT include characters
            outside the set %x21 / %x23-5B / %x5D-7E.

        state
            REQUIRED if a "state" parameter was present in the client
            authorization request.  The exact value received from the
            client.

    We use the RFC's error code description as the value for error_description,
    and for now we don't include an error_uri.
"""
import urllib

from aiohttp import web_exceptions


class _AuthorizationResponse(web_exceptions.HTTPFound):
    """ Base class for authorization responses.
    """

    def __init__(self, redirect_uri, state):
        """ Creates a new error response, including the state parameter if it
        was present in the request.
        """
        if state is not None:
            self.params['state'] = state
        # For now, skip url parsing. urllib.parse isn't very reliable and the
        # spec requires only string comparison for the request_uri request
        # parameter. Instead of parsing this as a URL, I'll only check whether
        # redirect_uri already includes a question mark to decide what separator
        # to use. Note that at this point we don't have to check whether the
        # q-mark is part of a fragment; fragments aren't allowed in
        # redirect_uris and should be disallowed during client registration.
        separator = (redirect_uri.find('?') >= 0 and '&') or '?'
        location = '{}{}{}'.format(
            redirect_uri, separator, urllib.parse.urlencode(self.params)
        )
        super().__init__(location)

    @property
    def params(self):
        """ Discourage direct instantiation.
        """
        raise NotImplementedError


class AuthorizationCode(_AuthorizationResponse):
    """ A successful authorization response for the “authorization grant” flow.
    """

    def __init__(self, code, redirect_uri, state):
        self.__class__.params = {'code': code}
        super().__init__(redirect_uri, state)


class InvalidRequest(_AuthorizationResponse):
    params = {
        'error': 'invalid_request',
        'error_description': 'The request is missing a required parameter,'
                             ' includes an invalid parameter value,'
                             ' includes a parameter more than once, or is'
                             ' otherwise malformed.'
    }


class UnauthorizedClient(_AuthorizationResponse):
    params = {
        'error': 'unauthorized_client',
        'error_description': 'The client is not authorized to request an'
                             ' authorization code using this method.'
    }


class AccessDenied(_AuthorizationResponse):
    params = {
        'error': 'access_denied',
        'error_description': 'The resource owner or authorization server'
                             ' denied the request.'
    }


class UnsupportedResponseType(_AuthorizationResponse):
    params = {
        'error': 'unsupported_response_type',
        'error_description': 'The authorization server does not support'
                             ' obtaining an access token using this method.'
    }


class InvalidScope(_AuthorizationResponse):
    params = {
        'error': 'invalid_scope',
        'error_description': 'The requested scope is invalid, unknown, or'
                             ' malformed.'
    }


class ServerError(_AuthorizationResponse):
    params = {
        'error': 'server_error',
        'error_description': 'The authorization server encountered an'
                             ' unexpected condition that prevented it from'
                             ' fulfilling the request.'
    }


class TemporarilyUnavailable(_AuthorizationResponse):
    params = {
        'error': 'temporarily_unavailable',
        'error_description': 'The authorization server is currently unable'
                             ' to handle the request due to a temporary'
                             ' overloading or maintenance of the server.'
    }
